这段 Go 语言代码使用了 `sync.WaitGroup` 来等待三个 goroutines 完成它们的任务后继续执行主程序。下面是代码的详细解析：

1. **初始化 WaitGroup**:
   - 创建了一个 `sync.WaitGroup` 对象 `wg`。
   - 调用 `wg.Add(3)` 来设置初始的未完成任务数量为 3。这表示接下来将有三个子任务需要等待完成。

2. **启动 Goroutines**:
   - 使用 `go` 关键字启动了三个匿名函数作为 goroutines。
   - 每个 goroutine 在完成任务后会调用 `defer wg.Done()` 来减少未完成任务的数量。
     - 第一个 goroutine 输出 "大儿子关水完毕"。
     - 第二个 goroutine 输出 "二儿子关电完毕"。
     - 第三个 goroutine 输出 "三儿子关燃气完毕"。

3. **等待所有 Goroutines 完成**:
   - `wg.Wait()` 会阻塞当前 goroutine（这里是 `main` 函数）直到 `WaitGroup` 的未完成任务数量变为 0。

4. **主程序继续执行**:
   - 当所有的 goroutines 都完成了任务后，`wg.Wait()` 返回，主程序继续执行。
   - 最后输出 "出发啦~~" 表示一切准备就绪，可以出发去郊游了。

### 运行结果预期
当你运行这个程序时，你可能会看到类似这样的输出：

```
大儿子关水完毕
二儿子关电完毕
三儿子关燃气完毕
出发啦~~
```

注意，由于 goroutines 的调度是非确定性的，所以 "大儿子关水完毕"、"二儿子关电完毕" 和 "三儿子关燃气完毕" 的输出顺序可能不同。但是，"出发啦~~" 总是出现在最后，表明所有准备工作都已经完成。

这个程序展示了如何使用 `sync.WaitGroup` 来确保主程序等待其他 goroutines 完成后再继续执行。这种方式非常适合用来同步并发任务。